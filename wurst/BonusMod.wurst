package BonusMod

import AbilityObjEditing
import ObjectIdGenerator
import public Stats
import Preloader

/*
This system is based on Bonus Mod by
    Earth-Fury
based on the work of
    weaaddar
*/

constant int MAX_LEVEL = 16 //2^16 = 65k, should be enough

/*
0...MAX_LEVEL-1 positive -> MAX_LEVEL positive abilities
MAX_LEVEL negative
*/
constant int MAX_BONUS = (2).pow(MAX_LEVEL)-1
constant int MIN_BONUS = -MAX_BONUS-1
//regen stats are handled via trigger

//movement speed is also handled via trigger
constant BM_HIT_POINTS = compiletime(generateIds())
constant BM_MANA_POINTS = compiletime(generateIds())

constant BM_ATTACK_SPEED = compiletime(generateIds())
constant BM_ATTACK_DAMAGE = compiletime(generateIds())
constant BM_ARMOR = compiletime(generateIds())

constant BM_STRENGTH = compiletime(generateIds())
constant BM_AGILITY = compiletime(generateIds())
constant BM_INTELLIGENCE = compiletime(generateIds())

int array abilityIds

int indexHP
int indexMP

int indexAD
int indexAS
int indexAR

int indexSTR
int indexAGI
int indexINT


int array powersOfTwo

int offset = 0
function fillArray(IdGenerator gen) returns int
    for i = 0 to MAX_LEVEL
        abilityIds[offset + i] = gen.next()
    offset += MAX_LEVEL + 1
    destroy gen
    return offset - MAX_LEVEL - 1

function createAbilityIdArray()
    indexHP = fillArray(new IdGenerator(BM_HIT_POINTS))
    indexMP = fillArray(new IdGenerator(BM_MANA_POINTS))
    indexAD = fillArray(new IdGenerator(BM_ATTACK_DAMAGE))
    indexAS = fillArray(new IdGenerator(BM_ATTACK_SPEED))
    indexAR = fillArray(new IdGenerator(BM_ARMOR))
    indexSTR = fillArray(new IdGenerator(BM_STRENGTH))
    indexAGI = fillArray(new IdGenerator(BM_AGILITY))
    indexINT = fillArray(new IdGenerator(BM_INTELLIGENCE))

function generateIds() returns int
    let first = ABIL_ID_GEN.next()
    for i = 0 to MAX_LEVEL
        ABIL_ID_GEN.next()

    return first


function statToBonusAbiltiy(Stat whichStat) returns integer
    
    switch whichStat.toInt()
        case Stat.AD.toInt()
            return indexAD
        case Stat.AS.toInt()
            return indexAS
        case Stat.AR.toInt()
            return indexAR
        case Stat.HP.toInt()
            return indexHP
        case Stat.MP.toInt()
            return indexMP
        case Stat.STR.toInt()
            return indexSTR
        case Stat.AGI.toInt()
            return indexAGI
        case Stat.INT.toInt()
            return indexINT
        default
            print("Error. This stat does not use abilities.")
            return -1
            
public function unit.setBonus(Stat whichStat, int bonus)

    if not IsUnitIdType(this.getTypeId(), UNIT_TYPE_HERO) // isType(UNIT_TYPE_HERO) returns false for illusions
        if whichStat == Stat.STR or whichStat == Stat.AGI or whichStat == Stat.INT
            return

    if(bonus > MAX_BONUS)
        print("Error. This Bonus is too high.")
        return

    if(bonus < MIN_BONUS)
        print("Error. This Bonus is too low.")
        return

    let index = statToBonusAbiltiy(whichStat)
    if index == -1
        return

    var remainingBonus = bonus
    if( bonus < 0)
        remainingBonus = MAX_BONUS + bonus + 1
        this.addAbility(abilityIds[index + MAX_LEVEL])
        this.makeAbilityPermanent(abilityIds[index + MAX_LEVEL], true)
    else
        this.removeAbility(abilityIds[index + MAX_LEVEL])

    for i = MAX_LEVEL-1 downto 0
        let iBonus = powersOfTwo[i]
        if remainingBonus >= iBonus
            this.addAbility(abilityIds[index + i])
            this.makeAbilityPermanent(abilityIds[index + i], true)
            remainingBonus -= iBonus
        else
            this.removeAbility(abilityIds[index + i])

public function unit.getBonus(Stat whichStat) returns int
    int amount = 0

    let index = statToBonusAbiltiy(whichStat)

    if this.hasAbility(abilityIds[index])
        amount = MIN_BONUS

    for i = 0 to MAX_LEVEL-1
        if this.hasAbility(abilityIds[index + i])
            amount += powersOfTwo[i]

    return amount

public function unit.addBonus(Stat whichStat, int bonus)
    this.setBonus(whichStat, this.getBonus(whichStat)+bonus)

init
    for i = 0 to MAX_LEVEL
        powersOfTwo[i] = (2).pow(i)

    for i = 0 to offset - 1
        preloadAbility(abilityIds[i])

        



@compiletime
function generateHitPointBonus()
    let gen = new IdGenerator(BM_HIT_POINTS)
    AbilityDefinitionMaxLifeBonusLeast aDef
    for i = 0 to MAX_LEVEL-1
        aDef = new AbilityDefinitionMaxLifeBonusLeast(gen.next())
        aDef.setMaxLifeGained(1, (2).pow(i) )

    aDef = new AbilityDefinitionMaxLifeBonusLeast(gen.next())
    aDef.setMaxLifeGained(1, -(2).pow(MAX_LEVEL) )
    destroy gen

@compiletime
function generateManaPointBonus()
    let gen = new IdGenerator(BM_MANA_POINTS)
    AbilityDefinitionMaxManaBonusLeast aDef
    for i = 0 to MAX_LEVEL-1
        aDef = new AbilityDefinitionMaxManaBonusLeast(gen.next())
        aDef.setMaxManaGained(1, (2).pow(i) )

    aDef = new AbilityDefinitionMaxManaBonusLeast(gen.next())
    aDef.setMaxManaGained(1, -(2).pow(MAX_LEVEL) )
    destroy gen
        
@compiletime
function generateAttackSpeedBonus()
    let gen = new IdGenerator(BM_ATTACK_SPEED)
    AbilityDefinitionAttackSpeedIncrease aDef
    for i = 0 to MAX_LEVEL-1
        aDef = new AbilityDefinitionAttackSpeedIncrease(gen.next())
        aDef.setAttackSpeedIncrease(1, (2).pow(i)/100 )

    aDef = new AbilityDefinitionAttackSpeedIncrease(gen.next())
    aDef.setAttackSpeedIncrease(1, -(2).pow(MAX_LEVEL)/100 )
    destroy gen

@compiletime
function generateAttackDamageBonus()
    let gen = new IdGenerator(BM_ATTACK_DAMAGE)
    AbilityDefinitionAttackBonus aDef
    for i = 0 to MAX_LEVEL-1
        aDef = new AbilityDefinitionAttackBonus(gen.next())
        aDef.setAttackBonus(1, (2).pow(i) )

    aDef = new AbilityDefinitionAttackBonus(gen.next())
    aDef.setAttackBonus(1, -(2).pow(MAX_LEVEL) )
    destroy gen
                
@compiletime
function generateArmorBonus()
    let gen = new IdGenerator(BM_ARMOR)
    AbilityDefinitionDefenseBonusPlus1 aDef
    for i = 0 to MAX_LEVEL-1
        aDef = new AbilityDefinitionDefenseBonusPlus1(gen.next())
        aDef.setDefenseBonus(1, (2).pow(i) )

    aDef = new AbilityDefinitionDefenseBonusPlus1(gen.next())
    aDef.setDefenseBonus(1, -(2).pow(MAX_LEVEL) )
    destroy gen
     
@compiletime
function generateStrengthBonus()
    let gen = new IdGenerator(BM_STRENGTH)
    AbilityDefinitionStrengthBonusPlus1 aDef
    for i = 0 to MAX_LEVEL-1
        aDef = new AbilityDefinitionStrengthBonusPlus1(gen.next())
        aDef.setStrengthBonus(1, (2).pow(i) )

    aDef = new AbilityDefinitionStrengthBonusPlus1(gen.next())
    aDef.setStrengthBonus(1, -(2).pow(MAX_LEVEL) )
    destroy gen
             
@compiletime
function generateAgilityBonus()
    let gen = new IdGenerator(BM_AGILITY)
    AbilityDefinitionAgilityBonusPlus1 aDef
    for i = 0 to MAX_LEVEL-1
        aDef = new AbilityDefinitionAgilityBonusPlus1(gen.next())
        aDef.setAgilityBonus(1, (2).pow(i) )

    aDef = new AbilityDefinitionAgilityBonusPlus1(gen.next())
    aDef.setAgilityBonus(1, -(2).pow(MAX_LEVEL) )
    destroy gen
             
@compiletime
function generateIntelligenceBonus()
    let gen = new IdGenerator(BM_INTELLIGENCE)
    AbilityDefinitionIntelligenceBonusPlus1 aDef
    for i = 0 to MAX_LEVEL-1
        aDef = new AbilityDefinitionIntelligenceBonusPlus1(gen.next())
        aDef.setIntelligenceBonus(1, (2).pow(i) )

    aDef = new AbilityDefinitionIntelligenceBonusPlus1(gen.next())
    aDef.setIntelligenceBonus(1, -(2).pow(MAX_LEVEL) )
    destroy gen

init
    createAbilityIdArray()