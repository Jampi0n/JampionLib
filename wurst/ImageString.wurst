package ImageString

import ImageChar
import LinkedList
import HashMap
import MapBounds
import ErrorHandling

/*
    Creates images for letters in a string
*/

public enum Origin
    TOP_LEFT
    TOP_CENTER
    MIDDLE_LEFT
    MIDDLE_CENTER

constant CHAR_SIZE = 32
constant CHAR_HOR_OFFSET = 5 
constant CHAR_VER_OFFSET = 10 
constant MAX_IMAGES = 1000

/*
    Stores position information of a string, so it can be quickly created as ImageString.
*/
public class ImageStringType

    protected real width
    protected Origin origin
    protected string message
    protected real size



    private int numberOfLines
    private LinkedList<string> lines
    private HashMap<int,int> widthPerLine
    private int arrayId
    private int arrayStartIndex

    protected int numberOfImages
    protected static int currentArray = 0 //store in multiple arrays from index 1 to 31k
    protected static int currentIndex = 0
    protected static string array imagePath0
    protected static string array imagePath1
    protected static string array imagePath2
    protected static string array imagePath3
    protected static real array charX0
    protected static real array charX1
    protected static real array charX2
    protected static real array charX3
    protected static real array charY0
    protected static real array charY1
    protected static real array charY2
    protected static real array charY3
    protected static int currentColorIndex = 0
    protected static colorA array col0
    protected static colorA array col1
    protected static colorA array col2
    protected static colorA array col3

    function saveChar(string path, real x, real y)
        if this.arrayId < 2
            if this.arrayId == 0
                ImageStringType.imagePath0[currentIndex] = path
                ImageStringType.charX0[currentIndex] = x
                ImageStringType.charY0[currentIndex] = y
            else
                ImageStringType.imagePath1[currentIndex] = path
                ImageStringType.charX1[currentIndex] = x
                ImageStringType.charY1[currentIndex] = y
        else
            if this.arrayId == 2
                ImageStringType.imagePath2[currentIndex] = path
                ImageStringType.charX2[currentIndex] = x
                ImageStringType.charY2[currentIndex] = y
            else
                ImageStringType.imagePath3[currentIndex] = path
                ImageStringType.charX3[currentIndex] = x
                ImageStringType.charY3[currentIndex] = y

        currentIndex++

    function saveColor(colorA col)
        if this.arrayId < 2
            if this.arrayId == 0
                ImageStringType.col0[currentColorIndex] = col
            else
                ImageStringType.col1[currentColorIndex] = col
        else
            if this.arrayId == 2
                ImageStringType.col2[currentColorIndex] = col
            else
                ImageStringType.col3[currentColorIndex] = col

        currentColorIndex++

    function createAsImage(vec2 pos, int index) returns image
        string path
        real x
        real y
        colorA col
        if this.arrayId < 2
            if this.arrayId == 0
                path = ImageStringType.imagePath0[this.arrayStartIndex + index]
                x = ImageStringType.charX0[this.arrayStartIndex + index]
                y = ImageStringType.charY0[this.arrayStartIndex + index]
                col = ImageStringType.col0[this.arrayStartIndex + index]
            else
                path = ImageStringType.imagePath1[this.arrayStartIndex + index]
                x = ImageStringType.charX1[this.arrayStartIndex + index]
                y = ImageStringType.charY1[this.arrayStartIndex + index]
                col = ImageStringType.col1[this.arrayStartIndex + index]
        else
            if this.arrayId == 2
                path = ImageStringType.imagePath2[this.arrayStartIndex + index]
                x = ImageStringType.charX2[this.arrayStartIndex + index]
                y = ImageStringType.charY2[this.arrayStartIndex + index]
                col = ImageStringType.col2[this.arrayStartIndex + index]
            else
                path = ImageStringType.imagePath3[this.arrayStartIndex + index]
                x = ImageStringType.charX3[this.arrayStartIndex + index]
                y = ImageStringType.charY3[this.arrayStartIndex + index]
                col = ImageStringType.col3[this.arrayStartIndex + index]


        let img = createImage(path, pos + vec2(x, y) ,CHAR_SIZE * size, CHAR_SIZE * size, Layer.L1)
        img.setColor(col)

        return img




    construct(real width, Origin origin, string message, real size)
        this.width = width
        this.origin = origin
        this.message = message
        this.size = size

        this.arrayId = currentArray
        this.arrayStartIndex = currentIndex

        //split string into substrings for every line
        this.lines = splitStringIntoLines()

        //create positions
        createPositions()
        if currentIndex >= 31760 //next string could reach limit
            currentIndex = 0
            currentArray++
            print("!!! array id is now " + currentArray.toString() + "!!!")
            if currentArray > 4
                error("character limit reached!")


    private function createPositions()
        this.numberOfImages = 0

        this.numberOfLines = this.lines.size()

        int lineIndex = 0

        int currentHeight = 0

        real originY = 0
        real array originX


        if this.origin == Origin.TOP_LEFT or  this.origin == Origin.TOP_CENTER
            originY = - CHAR_SIZE * 0.5 * size
        else if this.origin == Origin.MIDDLE_LEFT or this.origin == Origin.MIDDLE_CENTER
            originY = (numberOfLines-1) * 0.5 * (CHAR_SIZE + CHAR_VER_OFFSET) * size



        else if this.origin == Origin.MIDDLE_CENTER

        for string line in lines
            int currentWidth = 0

            print("line ="+line)

            bool setOriginX = false


            int currentPos = 0
            int length = line.length()
            while currentPos < length
                string c = line.charAt(currentPos)

                

                if c == "|"
                    currentPos++
                    
                    string specialCode = "|"

                    while true
                        string readC = line.charAt(currentPos)
                        
                        if readC == "|"
                            break
                        specialCode += readC
                        currentPos++

                    print("read special code (pos): >>"+specialCode+"<<")

                    c = specialCode

                print("c="+c)

                let imageChar = ImageChar.getImageToChar(c)
                if imageChar != null
                    if not setOriginX
                        if this.origin == Origin.TOP_CENTER or this.origin == Origin.MIDDLE_CENTER
                            originX[lineIndex]  =  - widthPerLine.get(lineIndex) * 0.5 * size + CHAR_SIZE * size * 0.5
                        else if this.origin == Origin.TOP_LEFT or this.origin == Origin.MIDDLE_LEFT
                            originX[lineIndex] = CHAR_SIZE * 0.5 * size
                        setOriginX = true

                    /*let arrayIndex = this.numberOfImages + MAX_IMAGES * (this castTo int) 
                    ImageStringType.imagePath[arrayIndex] = imageChar.getFilePath()
                    ImageStringType.charX[arrayIndex] = originX[lineIndex] + currentWidth * size
                    ImageStringType.charY[arrayIndex] = originY + ( -currentHeight + imageChar.getVerticalOffset())  * size*/
                    this.saveChar(imageChar.getFilePath(),  originX[lineIndex] + currentWidth * size, originY + ( -currentHeight + imageChar.getVerticalOffset())  * size)
                    this.numberOfImages++
                    currentWidth += imageChar.getWidth() + CHAR_HOR_OFFSET

                    print("save char")

                currentPos++

            lineIndex++
            currentHeight += CHAR_SIZE + CHAR_VER_OFFSET

    private function splitStringIntoLines() returns LinkedList<string>
        int currentLine = 0

        //The width of the word that is currently being read.
        //If the word ends its width is added to lineStringWidth.
        int lineReadWidth = 0
        int lineStringWidth = 0
        //The word that is currently being read.
        //If the word ends it is added to lineString.
        string lineReadWord = ""
        string lineString = ""

        colorA currentColor = COLOR_WHITE

        let list = new LinkedList<string>
        this.widthPerLine = new HashMap<int,int>
        int i = MAX_IMAGES * (this castTo int)
        int currentPos = 0
        int length = this.message.length()
        while currentPos < length
            bool continue = false
            //read char
            string c = this.message.charAt(currentPos)

            string checkCode = c + this.message.charAt(currentPos+1)
            if not continue and checkCode == "|c"
                //print("[START COLORCODE]")
                currentColor = fromHexString(this.message.substring(currentPos+2, currentPos+9))
                currentPos += 9
                continue = true

            if not continue and checkCode == "|r"
                //print("[END COLORCODE]")
                currentColor = COLOR_WHITE
                currentPos += 1
                continue = true

            if not continue and checkCode == "|n"
                lineString += lineReadWord
                list.add(lineString)
                //print("[SPLIT NEWLINE] >>" + lineString + "<<" + "width = " + (lineStringWidth + lineReadWidth).toString() )
                widthPerLine.put(currentLine, lineStringWidth + lineReadWidth)
                currentLine++
                lineString = ""
                lineStringWidth = 0
                lineReadWord = ""
                lineReadWidth = 0
                currentPos += 1
                continue = true

            if not continue and checkCode == "||" //special character
                currentPos += 2
                string specialCode = "|"
                while true
                    string readC = this.message.charAt(currentPos)
                    if readC == "|"
                        break
                    specialCode += readC
                    currentPos++


                //print("read special code (width): >>"+specialCode+"<<")

                let imageChar = ImageChar.getImageToChar(specialCode)
                if imageChar != null
                    lineReadWidth += imageChar.getWidth() + CHAR_HOR_OFFSET
                    lineReadWord += specialCode + "|"
                    this.saveColor(COLOR_WHITE)

                continue = true



            if not continue
                let imageChar = ImageChar.getImageToChar(c)
                if imageChar != null
                    lineReadWidth += imageChar.getWidth() + CHAR_HOR_OFFSET
                    lineReadWord += c
                    this.saveColor(currentColor)
                    //ImageStringType.col[i] = currentColor

                    //print("save color: "+i.toString())
                    i++
                    //print("Read: >>" + currentColor.toColorString()+ c +"|r<<")

            if not continue and c == " "
                lineString += lineReadWord
                lineStringWidth += lineReadWidth
                lineReadWord = ""
                lineReadWidth = 0
                continue = true

            

            if not continue and (lineStringWidth + lineReadWidth) * size > width
                list.add(lineString)
                widthPerLine.put(currentLine, lineStringWidth)
                //print("[SPLIT WIDTH] >>" + lineString + "<<" + "width = " + lineStringWidth.toString() )
                currentLine++
                lineString = ""
                lineStringWidth = 0

            currentPos++

        lineString += lineReadWord
        lineStringWidth += lineReadWidth
        //print("[SPLIT END] >>" + lineString + "<<" + "width = " + (lineStringWidth).toString() )
        list.add(lineString)
        widthPerLine.put(currentLine, lineStringWidth)

        /*let list = new LinkedList<string>
        this.widthPerLine = new HashMap<int,int>

        int i = 0
        int currentPos = 0
        int length = this.message.length()
        while currentPos < length
            bool continue = false
            string c = this.message.charAt(currentPos)
            let imageChar = ImageChar.getImageToChar(c)
            if imageChar != null
                currentWidth += imageChar.getWidth() + CHAR_HOR_OFFSET
                ImageStringType.col[i] = currentColor
                i++
            currentPos++

            string checkCode = c + this.message.charAt(currentPos)

            bool colorCode = checkCode == "|c"
            if not continue and colorCode
                currentColor = fromHexString(this.message.substring(currentPos+1, currentPos+9))

            //print("checkLineBreak >>"+checkLineBreak+"<<")
            bool lineBreak = checkCode == "|n"
            if not continue and lineBreak
                //print("[SPLIT LB] >>"+this.message.substring(lastText, currentPos-1)+"<<")
                list.add(this.message.substring(lastText, currentPos-1))

                widthPerLine.put(currentLine, currentWidth)
                lastWidth = 0
                currentLine++

                currentPos++ //skip n of |n
                lastText = currentPos
                currentWidth = 0
                continue = true

            if not continue and currentWidth * size > width //string too long
                //print("[SPLIT LG] >>"+this.message.substring(lastText, currentText)+"<<")
                list.add(this.message.substring(lastText, currentText))

                widthPerLine.put(currentLine, lastWidth)
                lastWidth = 0
                currentLine++

                currentPos = currentText //go back to last word
                lastText = currentText
                currentWidth = 0
                continue = true
                

            if not continue and c == " " //word finished
                currentText = currentPos
                lastWidth = currentWidth

        //print("[SPLIT ED] >>"+this.message.substring(lastText, currentPos)+"<<")
        list.add(this.message.substring(lastText, currentPos))

        widthPerLine.put(currentLine, currentWidth)*/


        return list

class ImageNode
    ImageNode next
    image img
    construct(image img, ImageNode next)
        this.next = next
        this.img = img

class ImageList

    ImageNode root = null

    construct()

    function add(image img)
        this.root = new ImageNode(img, this.root)

    function destroyAll()
        ImageNode node = root
        while node != null
            DestroyImage(node.img)
            let prevNode = node
            node = node.next
            prevNode.next = null
            prevNode.img = null
            destroy prevNode

        destroy this

public class ImageString

    private vec2 pos
    private real width
    private Origin origin
    private string message
    private real size
    private colorA col
    private bool useColor

    //private int numberOfLines


    private LinkedList<string> lines
    private HashMap<int,int> widthPerLine
    //private static image array images

    
    //private LinkedList<image> images = new LinkedList<image> LinkedList does not work with images (TypeCasting)
    private ImageList images = new ImageList()


    private int numberOfImages

    /**
    Uses the specified color for all characters and ignores color codes)
    */
    construct(ImageStringType stringPreset, vec2 pos, colorA col)
        this.setup(stringPreset, pos, col, true, null)

    /**
    Uses the specified color for all characters and ignores color codes)
    */
    construct(ImageStringType stringPreset, vec2 pos, colorA col, player forPlayer)
        this.setup(stringPreset, pos, col, true, forPlayer)

    construct(ImageStringType stringPreset, vec2 pos)
        this.setup(stringPreset, pos, COLOR_WHITE, false, null)

    construct(ImageStringType stringPreset, vec2 pos, player forPlayer)
        this.setup(stringPreset, pos, COLOR_WHITE, false, forPlayer)

    /**
    Creates a simple ImageString. Can only contain one line and does not support text codes.
    */
    construct(string message, vec2 pos, colorA col, real size, bool centered)
        simpleSetup(message, pos, col, size, centered, null)

    /**
    Creates a simple ImageString. Can only contain one line and does not support text codes.
    */
    construct(string message, vec2 pos, colorA col, real size, bool centered, player forPlayer)
        simpleSetup(message, pos, col, size, centered, forPlayer)
        
    function simpleSetup(string message, vec2 pos, colorA col, real size, bool centered, player forPlayer)
        int i = 0
        //let arrayOffset = MAX_IMAGES * (this castTo int)
        int currentWidth = 0

        real originX
        int totalWidth = 0
        if centered
            for string c in message
                let imageChar = ImageChar.getImageToChar(c)
                if imageChar != null
                    totalWidth += imageChar.getWidth() + CHAR_HOR_OFFSET
            originX = - totalWidth * 0.5 * size + CHAR_SIZE * size * 0.5
        else
            originX = CHAR_SIZE * 0.5 * size
            

        for string c in message
            let imageChar = ImageChar.getImageToChar(c)
            if imageChar != null
                let newImage = createImage(imageChar.getFilePath(), pos + vec2(originX + currentWidth * size, 0) ,CHAR_SIZE * size, CHAR_SIZE * size, Layer.L1)
                currentWidth += imageChar.getWidth() + CHAR_HOR_OFFSET
                if newImage == null
                    print("newImage == null")
                newImage.setColor(col)
                if forPlayer == null or GetLocalPlayer() == forPlayer
                    newImage.show()
                //ImageString.images[i + arrayOffset] = newImage
                this.images.add(newImage)
                i++
                

        this.numberOfImages = i

    function setup(ImageStringType stringPreset, vec2 pos, colorA col, bool useColor, player forPlayer)
        this.pos = pos
        this.width = stringPreset.width
        this.origin = stringPreset.origin
        this.message = stringPreset.message
        this.size = stringPreset.size
        this.col = col
        this.useColor = useColor



        this.numberOfImages = stringPreset.numberOfImages

        //let arrayOffsetType = MAX_IMAGES * (stringPreset castTo int) 
        //let arrayOffsetThis = MAX_IMAGES * (this castTo int)

        for i = 0 to this.numberOfImages - 1
            //let arrayIndex = i + arrayOffsetType
            let newImage = stringPreset.createAsImage(pos, i)
            //createImage(ImageStringType.imagePath[arrayIndex], pos + vec2(ImageStringType.charX[arrayIndex], ImageStringType.charY[arrayIndex]) ,CHAR_SIZE * size, CHAR_SIZE * size)

            if newImage == null
                print("newImage == null")

            if useColor
                newImage.setColor(this.col)
            //else
                //newImage.setColor(ImageStringType.col[arrayIndex])
                //print("load color: "+arrayIndex.toString())
            if forPlayer == null or GetLocalPlayer() == forPlayer
                newImage.show()
            //ImageString.images[i + arrayOffsetThis] = newImage
            this.images.add(newImage)



    /*construct(vec2 pos, real width, Origin origin, string message, real size, colorA col)
        this.pos = pos
        this.width = width
        this.origin = origin
        this.message = message
        this.size = size
        this.col = col

        //split string into substrings for every line
        this.lines = splitStringIntoLines()

        //create images
        createImages()

    private function createImages()
        this.numberOfImages = 0

        this.numberOfLines = this.lines.size()

        int lineIndex = 0

        int currentHeight = 0

        real originX = this.pos.x
        real originY = this.pos.y

        if this.origin == Origin.TOP_LEFT or this.origin == Origin.MIDDLE_LEFT
            let c = ImageChar.getImageToChar(this.lines.getFirst().charAt(0))
            originX = this.pos.x + c.getWidth() * 0.5 * size

        if this.origin == Origin.TOP_LEFT or  this.origin == Origin.TOP_CENTER
            originY = this.pos.y - CHAR_SIZE * 0.5 * size
        else if this.origin == Origin.MIDDLE_LEFT or this.origin == Origin.MIDDLE_CENTER
            originY = this.pos.y + (numberOfLines-1) * 0.5 * (CHAR_SIZE + CHAR_VER_OFFSET) * size



        let arrayOffsetThis = MAX_IMAGES * (this castTo int)

        for string line in lines
            int currentWidth = 0



            bool setOriginX = false

            for string c in line
                let imageChar = ImageChar.getImageToChar(c)
                if imageChar != null
                    if not setOriginX
                        if this.origin == Origin.TOP_CENTER or this.origin == Origin.MIDDLE_CENTER
                            originX = this.pos.x - widthPerLine.get(lineIndex) * 0.5 * size + imageChar.getWidth() * size * 0.5
                            setOriginX = true
                            //print(widthPerLine.get(lineIndex))

                    let newImage = createImage(imageChar.getFilePath(), vec2(originX, originY) + vec2(currentWidth * size, (-currentHeight + imageChar.getVerticalOffset())  * size) ,CHAR_SIZE * size, CHAR_SIZE * size)
                    newImage.setColor(this.col)
                    newImage.show()
                    currentWidth += imageChar.getWidth() + CHAR_HOR_OFFSET
                    ImageString.images[arrayOffsetThis + numberOfImages] = newImage
                    this.numberOfImages++

            lineIndex++
            currentHeight += CHAR_SIZE + CHAR_VER_OFFSET
                    


    private function splitStringIntoLines() returns LinkedList<string>
        int currentLine = 0
        int currentWidth = 0
    
        int lastText = 0
        int currentText = 0
        int lastWidth = 0
    
        let list = new LinkedList<string>
        this.widthPerLine = new HashMap<int,int>
    
        int currentPos = 0
        int length = this.message.length()
        while currentPos < length
            bool continue = false
            string c = this.message.charAt(currentPos)
            let imageChar = ImageChar.getImageToChar(c)
            if imageChar != null
                currentWidth += imageChar.getWidth() + CHAR_HOR_OFFSET
            currentPos++
    
            string checkLineBreak = c + this.message.charAt(currentPos)
            //print("checkLineBreak >>"+checkLineBreak+"<<")
            bool lineBreak = checkLineBreak == "|n"
            if not continue and lineBreak
                //print("[SPLIT LB] >>"+this.message.substring(lastText, currentPos-1)+"<<")
                list.add(this.message.substring(lastText, currentPos-1))

                widthPerLine.put(currentLine, currentWidth)
                lastWidth = 0
                currentLine++

                currentPos++ //skip n of |n
                lastText = currentPos
                currentWidth = 0
                continue = true
    
            if not continue and currentWidth * size > width //string too long
                //print("[SPLIT LG] >>"+this.message.substring(lastText, currentText)+"<<")
                list.add(this.message.substring(lastText, currentText))

                widthPerLine.put(currentLine, lastWidth)
                lastWidth = 0
                currentLine++

                currentPos = currentText //go back to last word
                lastText = currentText
                currentWidth = 0
                continue = true
                
    
            if not continue and c == " " //word finished
                currentText = currentPos
                lastWidth = currentWidth
    
        //print("[SPLIT ED] >>"+this.message.substring(lastText, currentPos)+"<<")
        list.add(this.message.substring(lastText, currentPos))

        widthPerLine.put(currentLine, currentWidth)
    
    
        return list*/
        
    ondestroy
        //let arrayOffsetThis = MAX_IMAGES * (this castTo int)
        /*for i = 0 to this.numberOfImages - 1
            let img = ImageString.images[i + arrayOffsetThis]

            img.hide()
            img.remove()*/
        
        this.images.destroyAll()

        if lines != null
            destroy lines
        if widthPerLine != null
            destroy widthPerLine
        
init
    // the first image is null for some reason
    // it can still be destroyed with DestroyImage(null)
    createImage("Textures\\Abomination.blp", playableCenter, 64, 64)