package Buff

import TimerUtils
import LinkedList
import InstantDummyCaster
import OnUnitEnterLeave
import HashMap
import ErrorHandling
import ClosureTimers

int buffCount = 0
int buffListCount = 0
int buffTypeCount = 0


//configuration: setGetBuffListFunction


public interface GetBuffListFunction
    function getBuffList(unit u) returns BuffList

GetBuffListFunction getBuffListFunction = null

public function setGetBuffListFunction(GetBuffListFunction getBuffList)
    if getBuffListFunction != null
        error("The getBuffListFunction was already configured. If you use useNativeBuffListAllocation, you must not use setGetBuffListFunction.")
    else
        getBuffListFunction = getBuffList

//configuration: setCreateBuffListFunction

public interface CreaetBuffListFunction
    function createBuffList(unit u)

CreaetBuffListFunction createBuffListFunction = null

public function setCreateBuffListFunction(CreaetBuffListFunction createBuffList)
    if createBuffListFunction != null
        error("The createBuffListFunction was already configured. If you use useNativeBuffListAllocation, you must not use setCreateBuffListFunction.")
    else
        createBuffListFunction = createBuffList


/*
    configuration: useNativeBuffListAllocation
    autoamtically allocates buff lists when units are created and removes the list when the unit is removed
    If you use this method, setGetBuffListFunction must not be used by the user.
*/

constant unitToBuffList = new HashMap<unit, BuffList>()

public function useNativeBuffListAllocation()
    onLeave( () -> (begin
        if not getEnterLeaveUnit().hasAbility('Aloc')
            let bList = getBuffListFunction.getBuffList(getEnterLeaveUnit())

            if bList != null
                for Buff b in bList.getLinkedList()
                    b.dispel()

                destroy bList
                unitToBuffList.remove(getEnterLeaveUnit())
    end))

    setCreateBuffListFunction( (unit u) -> (begin
        let bList = new BuffList
        unitToBuffList.put(u, bList)
        return bList
    end))

    setGetBuffListFunction( (unit u) -> (begin
        let bList = unitToBuffList.get(u)
        return bList
    end))

/*
    configuration: dispelBuffsOnDeath
    autoamtically dispels buffs when a unit dies
*/

public function dispelBuffsOnDeath()
    CreateTrigger()
        ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_DEATH)
        ..addAction(() -> (begin
            //delay, so in case the unit dies inside a BuffEventClosure, the buff does not get destroyed.
            let u = GetTriggerUnit()
            doAfter(0, () ->(begin
            
                let bList = getBuffListFunction.getBuffList(u)

                if bList != null
                    for Buff b in bList.getLinkedList()
                        b.dispel()
            end))
        end))
        

/*
Idea: each unit can have every buff only once

The buff object contains dynamic information and its type
The type contains static information

Dynamic:
caster, target, duration
Static:
aura based ability and corresponding buff

Reapplying the same buff type does not create a new buff object, but rather increases duration of the previous one
and updates caster and other dynamic duration.

Buff types can have closures that will be executed in certain situations:
onFirst -> buff is used on a unit that does not have the buff
onStack -> buff is used on a unit that does have the buff
onApply -> is used on a unit
onExpire -> duration runs out
onDispel -> buff removed before duration runs out: dispel, death, invulnerability, ...
To detect this: use native buff management of wc3
The buff abilities must not work on dead or invulnerable units for example.
onEnd -> buff gone in any way

Different levels of the same buff:
This should only happen when a hero levels up and has now a stronger spell.
Therefore one can safely overwrite the old buff.
Realization:
1. stats of buffs as dynamic information -> can easily be overwritten
2. multiple buff types for same buff with different levels -> how is the same buff with a different level removed?

Ability List for a buff. Each ability inside this list should only be used for this buff.

Duration is fixed when the buff is applied -> use one shot timer


*/

/*
Null pointer warning

A Buff that is removed wants to remove itself from the unit's buff list.

However if a unit is removed the bufflist is removed first and then the bufflist removes all its buffs.

*/

public interface BuffEventClosure
    function run(Buff whichBuff)



public class BuffType

    /*

    onFirst -> buff is used on a unit that does not have the buff
    onStack -> buff is used on a unit that does have the buff
    onApply -> is used on a unit
    onExpire -> duration runs out
    onDispel -> buff removed before duration runs out: dispel, death, invulnerability, ...
    To detect this: use native buff management of wc3
    The buff abilities must not work on dead or invulnerable units for example.
    onEnd -> buff gone in any way

    */
    /*protected trigger onFirst
    protected trigger onStack
    protected trigger onApply
    protected trigger onExpire
    protected trigger onDispel
    protected trigger onEnd
    protected trigger onPeriodic*/

    protected LinkedList<BuffEventClosure> onFirst = null
    protected LinkedList<BuffEventClosure> onStack = null
    protected LinkedList<BuffEventClosure> onApply = null
    protected LinkedList<BuffEventClosure> onExpire = null
    protected LinkedList<BuffEventClosure> onDispel = null
    protected LinkedList<BuffEventClosure> onEnd = null
    protected LinkedList<BuffEventClosure> onPeriodic = null

    private real periodicTime = 1

    private constant int dummyAbilityId
    private constant int dummyOrderId

    private boolean magical
    private boolean positive
    private int buffId
    private LinkedList<int> abilities

    /** This buff is applied by using a dummy caster to cast the ability on the target. */
    construct(int abilityId, string orderString, int buffId, boolean positive, boolean magical)
        buffTypeCount++

        //onFirst -> cast the spell
        //onEnd -> dispel the buff
        this.positive = positive
        this.magical = magical

        this.dummyAbilityId = abilityId
        this.buffId = buffId
        this.dummyOrderId = OrderId(orderString)
        this.addFirstFunction( (Buff whichBuff) -> castDummySpell(whichBuff))
        this.addEndFunction( (Buff whichBuff) -> removeDummyBuff(whichBuff))



    /** This buff is applied by placing a hidden aura ability on the target. */
    construct(LinkedList<int> abilities, int buffId, boolean positive, boolean magical)
        //onFirst -> add the aura
        //onEnd -> remove aura and buff
        this.positive = positive
        this.magical = magical

        this.buffId = buffId
        this.abilities = abilities
        this.addFirstFunction( (Buff whichBuff) -> addAuraAbility(whichBuff))
        this.addEndFunction( (Buff whichBuff) -> removeAuraAbility(whichBuff))

    /* empty constructor, to be able to use constants */
    construct(boolean positive, boolean magical)
        this.positive = positive
        this.magical = magical

    function setup(LinkedList<int> abilities, int buffId)
        //onFirst -> add the aura
        //onEnd -> remove aura and buff
        this.buffId = buffId
        this.abilities = abilities
        this.addFirstFunction( (Buff whichBuff) -> addAuraAbility(whichBuff))
        this.addEndFunction( (Buff whichBuff) -> removeAuraAbility(whichBuff))


    static function castDummySpell(Buff whichBuff)
        let buffType = whichBuff.getBuffType()
        let target = whichBuff.getTarget()
        InstantDummyCaster.castTarget(DUMMY_PLAYER, buffType.dummyAbilityId, 1, buffType.dummyOrderId, target, target.getPos())


    static function removeDummyBuff(Buff whichBuff)
        let buffType = whichBuff.getBuffType()
        let target = whichBuff.getTarget()
        target.removeAbility(buffType.buffId)


    static function addAuraAbility(Buff whichBuff)
        let buffType = whichBuff.getBuffType()
        let target = whichBuff.getTarget()
        buffType.abilities.forEach( (int abilityId ) -> (begin
            target.addAbility(abilityId)
            target.makeAbilityPermanent(abilityId, true)
            target.setAbilityLevel(abilityId, whichBuff.getLevel())
        end) )

    static function removeAuraAbility(Buff whichBuff)
        let buffType = whichBuff.getBuffType()
        let target = whichBuff.getTarget()
        buffType.abilities.forEach( (int abilityId ) -> target.removeAbility(abilityId))
        target.removeAbility(buffType.buffId)

    function setPeriodicTime(real newTime)
        this.periodicTime = newTime

    function getPeriodicTime() returns real
        return this.periodicTime

    function isMagical() returns boolean
        return this.magical

    function isPositive() returns boolean
        return this.positive

    function addFirstFunction(BuffEventClosure cb)
        if(this.onFirst==null)
            this.onFirst = new LinkedList<BuffEventClosure>()
        this.onFirst.add(cb)

    function addStackFunction(BuffEventClosure cb)
        if(this.onStack==null)
            this.onStack = new LinkedList<BuffEventClosure>()
        this.onStack.add(cb)

    function addApplyFunction(BuffEventClosure cb)
        if(this.onApply==null)
            this.onApply = new LinkedList<BuffEventClosure>()
        this.onApply.add(cb)

    function addExpireFunction(BuffEventClosure cb)
        if(this.onExpire==null)
            this.onExpire = new LinkedList<BuffEventClosure>()
        this.onExpire.add(cb)

    function addDispelFunction(BuffEventClosure cb)
        if(this.onDispel==null)
            this.onDispel = new LinkedList<BuffEventClosure>()
        this.onDispel.add(cb)

    function addEndFunction(BuffEventClosure cb)
        if(this.onEnd==null)
            this.onEnd = new LinkedList<BuffEventClosure>()
        this.onEnd.add(cb)

    function addPeriodicFunction(BuffEventClosure cb)
        if(this.onPeriodic==null)
            this.onPeriodic = new LinkedList<BuffEventClosure>()
        this.onPeriodic.add(cb)

/** Keeps track of the buffs a certain unit has.
*/
public class BuffList 

    private LinkedList<Buff> linkedList

    construct()
        buffListCount++
        linkedList = new LinkedList<Buff>


    function add(Buff newBuff)
        this.linkedList.add(newBuff)

    function remove(Buff removeBuff)
        this.linkedList.remove(removeBuff)

    static function getBuffOfType(unit target, BuffType buffType) returns Buff
        Buff retBuff = null
        let buffList = getBuffListFunction.getBuffList(target)
        if buffType != null
            if buffList != null
                for Buff currentBuff in buffList.getLinkedList()
                    if(currentBuff.getBuffType() == buffType)
                        retBuff = currentBuff
                        break
        return retBuff

    static function hasBuffType(unit target, BuffType buffType) returns boolean
        return getBuffOfType(target, buffType) != null

    static function hasBuff(unit target, Buff whichBuff) returns boolean
        let buffList = getBuffListFunction.getBuffList(target)
        boolean ret = false
        if buffList != null
            for Buff bf in buffList.getLinkedList()
                if bf == whichBuff
                    ret = true
                    break

        return ret

    function getLinkedList() returns LinkedList<Buff>
        return this.linkedList

    ondestroy
        buffListCount--
        destroy linkedList

public class Buff

    private unit caster
    private unit target
    private int level
    private BuffType buffType
    private timer expireTimer
    private LinkedList<BuffEventClosure> onFirst
    private LinkedList<BuffEventClosure> onStack
    private LinkedList<BuffEventClosure> onApply
    private LinkedList<BuffEventClosure> onExpire
    private LinkedList<BuffEventClosure> onDispel
    private LinkedList<BuffEventClosure> onEnd
    private LinkedList<BuffEventClosure> onPeriodic
    private timer periodicTimer = null
    protected boolean destroyed = false

    private int customData = 0

    private static Buff currentBuff 

    construct(unit target, unit caster, real duration, BuffType buffType, int level)
        buffCount++
       
        this.expireTimer = getTimer()
            ..setData(this castTo int)
        if duration > -0.5
            this.expireTimer.start(duration, function expireStatic)

        if getBuffListFunction.getBuffList(target) == null //allocate new buffList
            createBuffListFunction.createBuffList(target)

        this.caster = caster
        this.target = target
        this.level = level
        this.buffType = buffType
        this.onFirst = buffType.onFirst
        this.onStack = buffType.onStack
        this.onApply = buffType.onApply
        this.onExpire = buffType.onExpire
        this.onDispel = buffType.onDispel
        this.onEnd = buffType.onEnd
        this.onPeriodic = buffType.onPeriodic
        if(this.onPeriodic!=null)
            this.periodicTimer = getTimer()
                ..setData(this castTo int)
                ..startPeriodic(buffType.getPeriodicTime(), function onPeriodicStatic)
        else
            this.periodicTimer = null

        currentBuff = this


        if(this.onApply!=null)
            for BuffEventClosure cb in this.onApply
                cb.run(this)

        let oldBuff = BuffList.getBuffOfType(this.target, this.buffType)

        if(oldBuff!=null)
            //print("stack")

            if oldBuff.destroyed == true
                print("old buff already destroyed")

            if(this.onStack!=null)
                for BuffEventClosure cb in this.onStack
                    cb.run(oldBuff)
            oldBuff.update(this.caster, duration, level)
            destroy this
        else
            //print("first")
            getBuffListFunction.getBuffList(target).add(this)
            if(this.onFirst!=null)
                for BuffEventClosure cb in this.onFirst
                    cb.run(this)

        //print(this.expireTimer.getRemaining())
        

    private function onPeriodic()
        if not destroyed
            currentBuff = this
            if(this.onPeriodic!=null)
                for BuffEventClosure cb in this.onPeriodic
                    cb.run(this)

    private static function onPeriodicStatic()
        let t = GetExpiredTimer()
        Buff thisBuff = t.getData() castTo Buff
        if thisBuff != null
            thisBuff.onPeriodic()
        
    
    private function expire()
        currentBuff = this
        if(this.onExpire!=null)
            for BuffEventClosure cb in this.onExpire
                cb.run(this)
        if(this.onEnd!=null)
            for BuffEventClosure cb in this.onEnd
                cb.run(this)
        destroy this

    function dispel()
        //print("dispel buff: ")
        //print((this castTo int).toString() )

        currentBuff = this
        if(this.onDispel!=null)
            for BuffEventClosure cb in this.onDispel
                cb.run(this)
        if(this.onEnd!=null)
            for BuffEventClosure cb in this.onEnd
                cb.run(this)
        destroy this

    private static function expireStatic()
        let t = GetExpiredTimer()
        Buff thisBuff = t.getData() castTo Buff
        if thisBuff != null
            thisBuff.expire()
        
    function update(unit newCaster, real newDuration, int newLevel)
        this.caster = newCaster
        this.level = newLevel
        if newDuration < -0.5 or newDuration > this.expireTimer.getRemaining()
            this.expireTimer.release()
            this.expireTimer = getTimer()
                ..setData(this castTo int)
            if newDuration > -0.5
                this.expireTimer.start(newDuration, function expireStatic)


    function getCaster() returns unit
        return this.caster

    function getTarget() returns unit
        return this.target

    function getBuffType() returns BuffType
        return this.buffType

    function getRemaining() returns real
        return this.expireTimer.getRemaining()

    function getLevel() returns int
        return this.level

    function getData() returns int
        return this.customData

    function setData(int data)
        this.customData = data

    //static function getTriggerBuff() returns Buff
        //return currentBuff

    ondestroy
        
        buffCount--
        destroyed = true

        BuffList buffList = getBuffListFunction.getBuffList(target)

        if buffList!=null
            buffList.remove(this)

        this.expireTimer.release()
        this.expireTimer.setData(0) //binds null to the timer
        if this.periodicTimer != null
            this.periodicTimer.release()
            this.periodicTimer.setData(0) //binds null to the timer

        this.customData = 0
        //do not modify triggers. They belong to the BuffType

public function debugBuff()
    print("BuffTypeCount = "+buffTypeCount.toString())
    print("BuffListCount = "+buffListCount.toString())
    print("BuffCount = "+buffCount.toString())