package ImageString

import ImageChar
import LinkedList
import HashMap
import MapBounds
import ErrorHandling
import TimerUtils

/*
    Creates images for letters in a string
*/

public enum Origin
    TOP_LEFT
    TOP_CENTER
    MIDDLE_LEFT
    MIDDLE_CENTER

constant CHAR_SIZE = 32
constant CHAR_HOR_OFFSET = 5 
constant CHAR_VER_OFFSET = 10 
constant MAX_IMAGES = 1000

/*
    Stores position information of a string, so it can be quickly created as ImageString.
*/
public class ImageStringType

    protected real width
    protected Origin origin
    protected string message
    protected real size



    private int numberOfLines
    private LinkedList<string> lines
    private HashMap<int,int> widthPerLine
    private int arrayId
    private int arrayStartIndex

    protected int numberOfImages
    protected static int currentArray = 0 //store in multiple arrays from index 1 to 31k
    protected static int currentIndex = 0
    protected static string array imagePath0
    protected static string array imagePath1
    protected static string array imagePath2
    protected static string array imagePath3
    protected static real array charX0
    protected static real array charX1
    protected static real array charX2
    protected static real array charX3
    protected static real array charY0
    protected static real array charY1
    protected static real array charY2
    protected static real array charY3
    protected static int array size0
    protected static int array size1
    protected static int array size2
    protected static int array size3
    protected static int currentColorIndex = 0
    protected static colorA array col0
    protected static colorA array col1
    protected static colorA array col2
    protected static colorA array col3

    @inline
    function saveChar(string path, real x, real y, int size)
        if this.arrayId < 2
            if this.arrayId == 0
                ImageStringType.imagePath0[currentIndex] = path
                ImageStringType.charX0[currentIndex] = x
                ImageStringType.charY0[currentIndex] = y
                ImageStringType.size0[currentIndex] = size
            else
                ImageStringType.imagePath1[currentIndex] = path
                ImageStringType.charX1[currentIndex] = x
                ImageStringType.charY1[currentIndex] = y
                ImageStringType.size1[currentIndex] = size
        else
            if this.arrayId == 2
                ImageStringType.imagePath2[currentIndex] = path
                ImageStringType.charX2[currentIndex] = x
                ImageStringType.charY2[currentIndex] = y
                ImageStringType.size2[currentIndex] = size
            else
                ImageStringType.imagePath3[currentIndex] = path
                ImageStringType.charX3[currentIndex] = x
                ImageStringType.charY3[currentIndex] = y
                ImageStringType.size3[currentIndex] = size

        currentIndex++

    @inline
    function saveColor(colorA col)
        if this.arrayId < 2
            if this.arrayId == 0
                ImageStringType.col0[currentColorIndex] = col
            else
                ImageStringType.col1[currentColorIndex] = col
        else
            if this.arrayId == 2
                ImageStringType.col2[currentColorIndex] = col
            else
                ImageStringType.col3[currentColorIndex] = col

        currentColorIndex++

    @inline
    function createAsImage(vec2 pos, int index) returns image
        string path
        real x
        real y
        colorA col
        int charSize
        let arrayIndex = this.arrayStartIndex + index
        if this.arrayId < 2
            if this.arrayId == 0
                path = ImageStringType.imagePath0[arrayIndex]
                x = ImageStringType.charX0[arrayIndex]
                y = ImageStringType.charY0[arrayIndex]
                col = ImageStringType.col0[arrayIndex]
                charSize = ImageStringType.size0[arrayIndex]
            else
                path = ImageStringType.imagePath1[arrayIndex]
                x = ImageStringType.charX1[arrayIndex]
                y = ImageStringType.charY1[arrayIndex]
                col = ImageStringType.col1[arrayIndex]
                charSize = ImageStringType.size1[arrayIndex]
        else
            if this.arrayId == 2
                path = ImageStringType.imagePath2[arrayIndex]
                x = ImageStringType.charX2[arrayIndex]
                y = ImageStringType.charY2[arrayIndex]
                col = ImageStringType.col2[arrayIndex]
                charSize = ImageStringType.size2[arrayIndex]
            else
                path = ImageStringType.imagePath3[arrayIndex]
                x = ImageStringType.charX3[arrayIndex]
                y = ImageStringType.charY3[arrayIndex]
                col = ImageStringType.col3[arrayIndex]
                charSize = ImageStringType.size3[arrayIndex]


        let img = createImage(path, pos + vec2(x, y), charSize * size, charSize * size, ImageLayer.L1)
        img.setColor(col)

        return img




    construct(real width, Origin origin, string message, real size)
        this.width = width
        this.origin = origin
        this.message = message
        this.size = size

        this.arrayId = currentArray
        this.arrayStartIndex = currentIndex

        //split string into substrings for every line
        this.lines = splitStringIntoLines()

        //create positions
        createPositions()
        if currentIndex >= 31760 //next string could reach limit
            currentIndex = 0
            currentArray++
            print("!!! array id is now " + currentArray.toString() + "!!!")
            if currentArray > 4
                error("character limit reached!")


    private function createPositions()
        this.numberOfImages = 0

        this.numberOfLines = this.lines.size()

        int lineIndex = 0

        int currentHeight = 0

        real originY = 0
        real array originX


        if this.origin == Origin.TOP_LEFT or  this.origin == Origin.TOP_CENTER
            originY = - CHAR_SIZE * 0.5 * size
        else if this.origin == Origin.MIDDLE_LEFT or this.origin == Origin.MIDDLE_CENTER
            originY = (numberOfLines-1) * 0.5 * (CHAR_SIZE + CHAR_VER_OFFSET) * size



        else if this.origin == Origin.MIDDLE_CENTER

        for string line in lines
            int currentWidth = 0

            bool setOriginX = false


            int currentPos = 0
            int length = line.length()
            while currentPos < length
                string c = line.charAt(currentPos)

                

                if c == "|"
                    currentPos++
                    
                    string specialCode = "|"

                    while true
                        string readC = line.charAt(currentPos)
                        
                        if readC == "|"
                            break
                        specialCode += readC
                        currentPos++

                    c = specialCode

                let imageChar = ImageChar.getImageToChar(c)
                if imageChar != null
                    if not setOriginX
                        if this.origin == Origin.TOP_CENTER or this.origin == Origin.MIDDLE_CENTER
                            originX[lineIndex]  =  - widthPerLine.get(lineIndex) * 0.5 * size + CHAR_SIZE * size * 0.5
                        else if this.origin == Origin.TOP_LEFT or this.origin == Origin.MIDDLE_LEFT
                            originX[lineIndex] = CHAR_SIZE * 0.5 * size
                        setOriginX = true

                    /*let arrayIndex = this.numberOfImages + MAX_IMAGES * (this castTo int) 
                    ImageStringType.imagePath[arrayIndex] = imageChar.getFilePath()
                    ImageStringType.charX[arrayIndex] = originX[lineIndex] + currentWidth * size
                    ImageStringType.charY[arrayIndex] = originY + ( -currentHeight + imageChar.getVerticalOffset())  * size*/
                    this.saveChar(imageChar.getFilePath(),  originX[lineIndex] + (currentWidth + (imageChar.getSize() - CHAR_SIZE)/2) * size, originY + ( -currentHeight + imageChar.getVerticalOffset() + (imageChar.getSize() - CHAR_SIZE)/2 )  * size, imageChar.getSize() )
                    this.numberOfImages++
                    currentWidth += imageChar.getWidth() + CHAR_HOR_OFFSET


                currentPos++

            lineIndex++
            currentHeight += CHAR_SIZE + CHAR_VER_OFFSET

    private function splitStringIntoLines() returns LinkedList<string>
        int currentLine = 0

        //The width of the word that is currently being read.
        //If the word ends its width is added to lineStringWidth.
        int lineReadWidth = 0
        int lineStringWidth = 0
        //The word that is currently being read.
        //If the word ends it is added to lineString.
        string lineReadWord = ""
        string lineString = ""

        colorA currentColor = COLOR_WHITE

        let list = new LinkedList<string>
        this.widthPerLine = new HashMap<int,int>
        int i = MAX_IMAGES * (this castTo int)
        int currentPos = 0
        int length = this.message.length()
        while currentPos < length
            bool continue = false
            //read char
            string c = this.message.charAt(currentPos)

            string checkCode = c + this.message.charAt(currentPos+1)
            if not continue and checkCode == "|c"
                //print("[START COLORCODE]")
                currentColor = fromHexString(this.message.substring(currentPos+2, currentPos+9))
                currentPos += 9
                continue = true

            if not continue and checkCode == "|r"
                //print("[END COLORCODE]")
                currentColor = COLOR_WHITE
                currentPos += 1
                continue = true

            if not continue and checkCode == "|n"
                lineString += lineReadWord
                list.add(lineString)
                //print("[SPLIT NEWLINE] >>" + lineString + "<<" + "width = " + (lineStringWidth + lineReadWidth).toString() )
                widthPerLine.put(currentLine, lineStringWidth + lineReadWidth)
                currentLine++
                lineString = ""
                lineStringWidth = 0
                lineReadWord = ""
                lineReadWidth = 0
                currentPos += 1
                continue = true

            if not continue and checkCode == "||" //special character
                currentPos += 2
                string specialCode = "|"
                while true
                    string readC = this.message.charAt(currentPos)
                    if readC == "|"
                        break
                    specialCode += readC
                    currentPos++


                //print("read special code (width): >>"+specialCode+"<<")

                let imageChar = ImageChar.getImageToChar(specialCode)
                if imageChar != null
                    lineReadWidth += imageChar.getWidth() + CHAR_HOR_OFFSET
                    lineReadWord += specialCode + "|"
                    this.saveColor(COLOR_WHITE)

                continue = true



            if not continue
                let imageChar = ImageChar.getImageToChar(c)
                if imageChar != null
                    lineReadWidth += imageChar.getWidth() + CHAR_HOR_OFFSET
                    lineReadWord += c
                    this.saveColor(currentColor)
                    //ImageStringType.col[i] = currentColor

                    //print("save color: "+i.toString())
                    i++
                    //print("Read: >>" + currentColor.toColorString()+ c +"|r<<")

            if not continue and c == " "
                lineString += lineReadWord
                lineStringWidth += lineReadWidth
                lineReadWord = ""
                lineReadWidth = 0
                continue = true

            

            if not continue and (lineStringWidth + lineReadWidth) * size > width
                list.add(lineString)
                widthPerLine.put(currentLine, lineStringWidth)
                //print("[SPLIT WIDTH] >>" + lineString + "<<" + "width = " + lineStringWidth.toString() )
                currentLine++
                lineString = ""
                lineStringWidth = 0

            currentPos++

        lineString += lineReadWord
        lineStringWidth += lineReadWidth
        //print("[SPLIT END] >>" + lineString + "<<" + "width = " + (lineStringWidth).toString() )
        list.add(lineString)
        widthPerLine.put(currentLine, lineStringWidth)

        /*let list = new LinkedList<string>
        this.widthPerLine = new HashMap<int,int>

        int i = 0
        int currentPos = 0
        int length = this.message.length()
        while currentPos < length
            bool continue = false
            string c = this.message.charAt(currentPos)
            let imageChar = ImageChar.getImageToChar(c)
            if imageChar != null
                currentWidth += imageChar.getWidth() + CHAR_HOR_OFFSET
                ImageStringType.col[i] = currentColor
                i++
            currentPos++

            string checkCode = c + this.message.charAt(currentPos)

            bool colorCode = checkCode == "|c"
            if not continue and colorCode
                currentColor = fromHexString(this.message.substring(currentPos+1, currentPos+9))

            //print("checkLineBreak >>"+checkLineBreak+"<<")
            bool lineBreak = checkCode == "|n"
            if not continue and lineBreak
                //print("[SPLIT LB] >>"+this.message.substring(lastText, currentPos-1)+"<<")
                list.add(this.message.substring(lastText, currentPos-1))

                widthPerLine.put(currentLine, currentWidth)
                lastWidth = 0
                currentLine++

                currentPos++ //skip n of |n
                lastText = currentPos
                currentWidth = 0
                continue = true

            if not continue and currentWidth * size > width //string too long
                //print("[SPLIT LG] >>"+this.message.substring(lastText, currentText)+"<<")
                list.add(this.message.substring(lastText, currentText))

                widthPerLine.put(currentLine, lastWidth)
                lastWidth = 0
                currentLine++

                currentPos = currentText //go back to last word
                lastText = currentText
                currentWidth = 0
                continue = true
                

            if not continue and c == " " //word finished
                currentText = currentPos
                lastWidth = currentWidth

        //print("[SPLIT ED] >>"+this.message.substring(lastText, currentPos)+"<<")
        list.add(this.message.substring(lastText, currentPos))

        widthPerLine.put(currentLine, currentWidth)*/


        return list

class ImageNode
    ImageNode next
    image img
    construct(image img, ImageNode next)
        this.next = next
        this.img = img

class ImageList

    ImageNode root = null

    construct()

    function add(image img)
        this.root = new ImageNode(img, this.root)

    function hideAll()
        ImageNode node = root
        while node != null
            node.img.hide()
            node = node.next

    function showAll()
        ImageNode node = root
        while node != null
            node.img.show()
            node = node.next

    function showAllForPlayer(player forPlayer)
        ImageNode node = root
        while node != null
            node.img.showForPlayer(forPlayer)
            node = node.next

    function changeColor(colorA col)
        ImageNode node = root
        while node != null
            node.img.setColor(col)
            node = node.next

    function destroyAll()
        ImageNode node = root
        while node != null
            if node.img != null
                DestroyImage(node.img)
            let prevNode = node
            node = node.next
            prevNode.next = null
            prevNode.img = null
            destroy prevNode

        destroy this

public class ImageString

    private vec2 pos
    private real width
    private Origin origin
    private string message
    private real size
    private colorA col
    private bool useColor

    private bool destroyed = false
    private timer textTimer = null
    private int createdImages = 0
    private ImageStringType stringPreset

    //private int numberOfLines


    private LinkedList<string> lines
    private HashMap<int,int> widthPerLine
    //private static image array images

    
    //private LinkedList<image> images = new LinkedList<image> LinkedList does not work with images (TypeCasting)
    private ImageList images = new ImageList()


    private int numberOfImages

    /**
    Uses the specified color for all characters and ignores color codes)
    */
    construct(ImageStringType stringPreset, vec2 pos, colorA col)
        this.setup(stringPreset, pos, col, true)


    construct(ImageStringType stringPreset, vec2 pos)
        this.setup(stringPreset, pos, COLOR_WHITE, false)


    /**
    Creates a simple ImageString. Can only contain one line and does not support text codes.
    */
    construct(string message, vec2 pos, colorA col, real size, bool centered)
        simpleSetup(message, pos, col, size, centered, null)

    /**
    Creates a simple ImageString. Can only contain one line and does not support text codes.
    */
    construct(string message, vec2 pos, colorA col, real size, bool centered, player forPlayer)
        simpleSetup(message, pos, col, size, centered, forPlayer)
        
    function simpleSetup(string message, vec2 pos, colorA col, real size, bool centered, player forPlayer)
        int i = 0
        //let arrayOffset = MAX_IMAGES * (this castTo int)
        int currentWidth = 0

        real originX
        real originY = - CHAR_SIZE * 0.5 * size
        int totalWidth = 0
        if centered
            for string c in message
                let imageChar = ImageChar.getImageToChar(c)
                if imageChar != null
                    totalWidth += imageChar.getWidth() + CHAR_HOR_OFFSET
            originX = - totalWidth * 0.5 * size + CHAR_SIZE * size * 0.5
        else
            originX = CHAR_SIZE * 0.5 * size
            
        for string c in message
            let imageChar = ImageChar.getImageToChar(c)
            if imageChar != null
                let newImage = createImage(imageChar.getFilePath(), pos + vec2(originX + (currentWidth + (imageChar.getSize() - CHAR_SIZE)/2) * size, originY + ( imageChar.getVerticalOffset() + (imageChar.getSize() - CHAR_SIZE)/2 )  * size), imageChar.getSize() * size, imageChar.getSize() * size, ImageLayer.L1)
                currentWidth += imageChar.getWidth() + CHAR_HOR_OFFSET
                if newImage == null
                    print("newImage == null")
                newImage.setColor(col)
                if forPlayer == null or GetLocalPlayer() == forPlayer
                    newImage.show()
                //ImageString.images[i + arrayOffset] = newImage
                this.images.add(newImage)
                i++
                

        this.numberOfImages = i

    private function createImg()
        for i = 0 to 31
            if this.createdImages == this.numberOfImages
                return
            let newImage = stringPreset.createAsImage(pos, this.createdImages)
            newImage.show()
            this.images.add(newImage)
            this.createdImages++
        if this.createdImages < this.numberOfImages and not this.destroyed
            this.textTimer.start(1.0/32, function onTimer)

    private function createImgColored()
        for i = 0 to 31
            if this.createdImages == this.numberOfImages
                return
            let newImage = stringPreset.createAsImage(pos, this.createdImages)
            newImage.setColor(this.col)
            newImage.show()
            this.images.add(newImage)
            this.createdImages++
        if this.createdImages < this.numberOfImages and not this.destroyed
            this.textTimer.start(1.0/32, function onTimerColored)

    private static function onTimer()
        let imgString = GetExpiredTimer().getData() castTo ImageString
        imgString.createImg()
    private static function onTimerColored()
        let imgString = GetExpiredTimer().getData() castTo ImageString
        imgString.createImgColored()

    private function setup(ImageStringType stringPreset, vec2 pos, colorA col, bool useColor)
        this.pos = pos
        this.width = stringPreset.width
        this.origin = stringPreset.origin
        this.message = stringPreset.message
        this.size = stringPreset.size
        this.col = col
        this.useColor = useColor
        this.stringPreset = stringPreset
        this.numberOfImages = stringPreset.numberOfImages


        this.textTimer = getTimer()
        this.textTimer.setData(this castTo int)
        if useColor
            createImgColored()
        else
            createImg()



        /*or i = 0 to this.numberOfImages - 1
            let newImage = stringPreset.createAsImage(pos, i)
            newImage.show()
            this.images.add(newImage)*/

        /*if useColor
            if forPlayer == null
                for i = 0 to this.numberOfImages - 1
                    let newImage = stringPreset.createAsImage(pos, i)
                    newImage.setColor(this.col)
                    newImage.show()
                    this.images.add(newImage)
            else
                for i = 0 to this.numberOfImages - 1
                    if this.destroyed
                        return
                    let newImage = stringPreset.createAsImage(pos, i)
                    newImage.setColor(this.col)
                    newImage.showForPlayer(forPlayer)
                    this.images.add(newImage)
        else
            if forPlayer == null
                for i = 0 to this.numberOfImages - 1
                    if this.destroyed
                        return
                    let newImage = stringPreset.createAsImage(pos, i)
                    newImage.show()
                    this.images.add(newImage)
            else
                for i = 0 to this.numberOfImages - 1
                    if this.destroyed
                        return
                    let newImage = stringPreset.createAsImage(pos, i)
                    newImage.showForPlayer(forPlayer)
                    this.images.add(newImage)*/

    function hide()
        this.images.hideAll()

    function show()
        this.images.showAll()

    function changeColor(colorA col)
        this.images.changeColor(col)

    function showForPlayer(player forPlayer)
        this.images.showAllForPlayer(forPlayer)
        
    ondestroy
        this.destroyed = true
        this.images.destroyAll()

        if lines != null
            destroy lines
        if widthPerLine != null
            destroy widthPerLine
        if textTimer != null
            textTimer.release()
        
init
    // the first image is null for some reason
    // it can still be destroyed with DestroyImage(null)
    createImage("Textures\\Abomination.blp", playableCenter, 64, 64)