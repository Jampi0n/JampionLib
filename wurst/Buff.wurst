package Buff

import TimerUtils
import LinkedList
import InstantDummyCaster
import OnUnitEnterLeave
import HashMap
import ErrorHandling
import ClosureTimers
import Execute

int buffCount = 0
int buffListCount = 0
int buffTypeCount = 0

public enum DispelLevel
    DISPEL
    BREAK
    NONE

//configuration: setGetBuffListFunction


public interface GetBuffListFunction
    function getBuffList(unit u) returns BuffList

GetBuffListFunction getBuffListFunction = null

public function setGetBuffListFunction(GetBuffListFunction getBuffList)
    if getBuffListFunction != null
        error("The getBuffListFunction was already configured. If you use useNativeBuffListAllocation, you must not use setGetBuffListFunction.")
    else
        getBuffListFunction = getBuffList

//configuration: setCreateBuffListFunction

public interface CreaetBuffListFunction
    function createBuffList(unit u)

CreaetBuffListFunction createBuffListFunction = null

public function setCreateBuffListFunction(CreaetBuffListFunction createBuffList)
    if createBuffListFunction != null
        error("The createBuffListFunction was already configured. If you use useNativeBuffListAllocation, you must not use setCreateBuffListFunction.")
    else
        createBuffListFunction = createBuffList


/*
    configuration: useNativeBuffListAllocation
    autoamtically allocates buff lists when units are created and removes the list when the unit is removed
    If you use this method, setGetBuffListFunction must not be used by the user.
*/

constant unitToBuffList = new HashMap<unit, BuffList>()

public function useNativeBuffListAllocation()
    onLeave( () -> (begin
        if not getEnterLeaveUnit().hasAbility('Aloc')
            let bList = getBuffListFunction.getBuffList(getEnterLeaveUnit())

            if bList != null
                for Buff b in bList.getLinkedList()
                    b.dispel()

                destroy bList
                unitToBuffList.remove(getEnterLeaveUnit())
    end))

    setCreateBuffListFunction( (unit u) -> (begin
        let bList = new BuffList
        unitToBuffList.put(u, bList)
        return bList
    end))

    setGetBuffListFunction( (unit u) -> (begin
        let bList = unitToBuffList.get(u)
        return bList
    end))

/*
    configuration: dispelBuffsOnDeath
    autoamtically dispels buffs when a unit dies
*/

public function dispelBuffsOnDeath()
    CreateTrigger()
    ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_DEATH)
    ..addAction(() -> (begin
        //delay, so in case the unit dies inside a BuffEventClosure, the buff does not get destroyed.
        let u = GetTriggerUnit()
        doAfter(0, () ->(begin
        
            let bList = getBuffListFunction.getBuffList(u)

            if bList != null
                for Buff b in bList.getLinkedList()
                    b.dispel()
        end))
    end))
        

/*
Idea: each unit can have every buff only once

The buff object contains dynamic information and its type
The type contains static information

Dynamic:
caster, target, duration
Static:
aura based ability and corresponding buff

Reapplying the same buff type does not create a new buff object, but rather increases duration of the previous one
and updates caster and other dynamic duration.

Buff types can have closures that will be executed in certain situations:
onFirst -> buff is used on a unit that does not have the buff
onStack -> buff is used on a unit that does have the buff
onApply -> is used on a unit
onExpire -> duration runs out
onDispel -> buff removed before duration runs out: dispel, death, invulnerability, ...
To detect this: use native buff management of wc3
The buff abilities must not work on dead or invulnerable units for example.
onEnd -> buff gone in any way

Different levels of the same buff:
This should only happen when a hero levels up and has now a stronger spell.
Therefore one can safely overwrite the old buff.
Realization:
1. stats of buffs as dynamic information -> can easily be overwritten
2. multiple buff types for same buff with different levels -> how is the same buff with a different level removed?

Ability List for a buff. Each ability inside this list should only be used for this buff.

Duration is fixed when the buff is applied -> use one shot timer


*/

/*
Null pointer warning

A Buff that is removed wants to remove itself from the unit's buff list.

However if a unit is removed the bufflist is removed first and then the bufflist removes all its buffs.

*/
public interface BuffEventClosure
    function run(Buff whichBuff)



public class BuffType

    /*

    onFirst -> buff is used on a unit that does not have the buff
    onStack -> buff is used on a unit that does have the buff
    onApply -> is used on a unit
    onExpire -> duration runs out
    onDispel -> buff removed before duration runs out: dispel, death, invulnerability, ...
    To detect this: use native buff management of wc3
    The buff abilities must not work on dead or invulnerable units for example.
    onEnd -> buff gone in any way

    */
    /*protected trigger onFirst
    protected trigger onStack
    protected trigger onApply
    protected trigger onExpire
    protected trigger onDispel
    protected trigger onEnd
    protected trigger onPeriodic*/

    protected LinkedList<BuffEventClosure> onFirst = null
    protected LinkedList<BuffEventClosure> onStack = null
    protected LinkedList<BuffEventClosure> onApply = null
    protected LinkedList<BuffEventClosure> onExpire = null
    protected LinkedList<BuffEventClosure> onDispel = null
    protected LinkedList<BuffEventClosure> onEnd = null
    protected LinkedList<BuffEventClosure> onPeriodic = null

    private real periodicTime = 1

    private constant int dummyAbilityId
    private constant int dummyOrderId

    private DispelLevel dispelLevel
    private boolean positive
    private int buffId
    private LinkedList<int> abilities

    /** This buff is applied by using a dummy caster to cast the ability on the target. */
    construct(int abilityId, string orderString, int buffId, boolean positive, DispelLevel dispelLevel)
        buffTypeCount++

        //onFirst -> cast the spell
        //onEnd -> dispel the buff
        this.positive = positive
        this.dispelLevel = dispelLevel

        this.dummyAbilityId = abilityId
        this.buffId = buffId
        this.dummyOrderId = OrderId(orderString)
        this.addFirstFunction( (Buff whichBuff) -> castDummySpell(whichBuff))
        this.addEndFunction( (Buff whichBuff) -> removeDummyBuff(whichBuff))



    /** This buff is applied by placing a hidden aura ability on the target. */
    construct(LinkedList<int> abilities, int buffId, boolean positive, DispelLevel dispelLevel)
        //onFirst -> add the aura
        //onEnd -> remove aura and buff
        this.positive = positive
        this.dispelLevel = dispelLevel

        this.buffId = buffId
        this.abilities = abilities
        this.addFirstFunction( (Buff whichBuff) -> addAuraAbility(whichBuff))
        this.addEndFunction( (Buff whichBuff) -> removeAuraAbility(whichBuff))

    /* empty constructor, to be able to use constants */
    construct(boolean positive, DispelLevel dispel)
        this.positive = positive
        this.dispelLevel = dispel

    function setupBuffWithIcon(int buffId, LinkedList<int> abilities)
        //onFirst -> add the aura
        //onEnd -> remove aura and buff
        this.buffId = buffId
        this.abilities = abilities
        this.addFirstFunction( (Buff whichBuff) -> addAuraAbility(whichBuff))
        this.addEndFunction( (Buff whichBuff) -> removeAuraAbility(whichBuff))

    function setupBuffWithIcon(int buffId, int abilityId)
        let list = new LinkedList<int>()
        list.add(abilityId)
        this.setupBuffWithIcon(buffId, list)

    function setupBuffWithIcon(int buffId, int abilityId1, int abilityId2)
        let list = new LinkedList<int>()
        list.add(abilityId1)
        list.add(abilityId2)
        this.setupBuffWithIcon(buffId, list)

    function setupBuffWithIcon(int buffId, int abilityId1, int abilityId2, int abilityId3)
        let list = new LinkedList<int>()
        list.add(abilityId1)
        list.add(abilityId2)
        list.add(abilityId3)
        this.setupBuffWithIcon(buffId, list)


    static function castDummySpell(Buff whichBuff)
        let buffType = whichBuff.getBuffType()
        let target = whichBuff.getTarget()
        InstantDummyCaster.castTarget(DUMMY_PLAYER, buffType.dummyAbilityId, 1, buffType.dummyOrderId, target, target.getPos())


    static function removeDummyBuff(Buff whichBuff)
        let buffType = whichBuff.getBuffType()
        let target = whichBuff.getTarget()
        target.removeAbility(buffType.buffId)


    static function addAuraAbility(Buff whichBuff)
        let buffType = whichBuff.getBuffType()
        let target = whichBuff.getTarget()
        buffType.abilities.forEach( (int abilityId ) -> (begin
            target.addAbility(abilityId)
            target.setAbilityLevel(abilityId, whichBuff.getLevel())
            target.makeAbilityPermanent(abilityId, true)
        end) )

    static function removeAuraAbility(Buff whichBuff)
        let buffType = whichBuff.getBuffType()
        let target = whichBuff.getTarget()
        buffType.abilities.forEach( (int abilityId ) -> target.removeAbility(abilityId))
        target.removeAbility(buffType.buffId)

    function setPeriodicTime(real newTime)
        this.periodicTime = newTime

    function getPeriodicTime() returns real
        return this.periodicTime

    function getDispelLevel() returns DispelLevel
        return this.dispelLevel

    function isPositive() returns boolean
        return this.positive

    function addFirstFunction(BuffEventClosure cb)
        if(this.onFirst==null)
            this.onFirst = new LinkedList<BuffEventClosure>()
        this.onFirst.add(cb)

    function addStackFunction(BuffEventClosure cb)
        if(this.onStack==null)
            this.onStack = new LinkedList<BuffEventClosure>()
        this.onStack.add(cb)

    function addApplyFunction(BuffEventClosure cb)
        if(this.onApply==null)
            this.onApply = new LinkedList<BuffEventClosure>()
        this.onApply.add(cb)

    function addExpireFunction(BuffEventClosure cb)
        if(this.onExpire==null)
            this.onExpire = new LinkedList<BuffEventClosure>()
        this.onExpire.add(cb)

    function addDispelFunction(BuffEventClosure cb)
        if(this.onDispel==null)
            this.onDispel = new LinkedList<BuffEventClosure>()
        this.onDispel.add(cb)

    function addEndFunction(BuffEventClosure cb)
        if(this.onEnd==null)
            this.onEnd = new LinkedList<BuffEventClosure>()
        this.onEnd.add(cb)

    function addPeriodicFunction(BuffEventClosure cb)
        if(this.onPeriodic==null)
            this.onPeriodic = new LinkedList<BuffEventClosure>()
        this.onPeriodic.add(cb)

/** Keeps track of the buffs a certain unit has.
*/
public class BuffList 

    private LinkedList<Buff> linkedList

    construct()
        buffListCount++
        linkedList = new LinkedList<Buff>


    function add(Buff newBuff)
        this.linkedList.add(newBuff)

    function remove(Buff removeBuff)
        this.linkedList.remove(removeBuff)

    static function getBuffOfType(unit target, BuffType buffType) returns Buff
        Buff retBuff = null
        let buffList = getBuffListFunction.getBuffList(target)
        if buffType != null
            if buffList != null
                for Buff currentBuff in buffList.getLinkedList()
                    if(currentBuff.getBuffType() == buffType)
                        retBuff = currentBuff
                        break
        return retBuff

    static function hasBuffType(unit target, BuffType buffType) returns boolean
        return getBuffOfType(target, buffType) != null

    static function hasBuff(unit target, Buff whichBuff) returns boolean
        let buffList = getBuffListFunction.getBuffList(target)
        boolean ret = false
        if buffList != null
            for Buff bf in buffList.getLinkedList()
                if bf == whichBuff
                    ret = true
                    break

        return ret

    function getLinkedList() returns LinkedList<Buff>
        return this.linkedList

    ondestroy
        buffListCount--
        destroy linkedList

public function Buff.setDispelLevel(DispelLevel dispelLevel)
    if this != null
        this.dispelLevel = dispelLevel

public class Buff

    private unit caster
    private unit target
    private int level
    private BuffType buffType
    private timer expireTimer
    private LinkedList<BuffEventClosure> onFirst
    private LinkedList<BuffEventClosure> onStack
    private LinkedList<BuffEventClosure> onApply
    private LinkedList<BuffEventClosure> onExpire
    private LinkedList<BuffEventClosure> onDispel
    private LinkedList<BuffEventClosure> onEnd
    private LinkedList<BuffEventClosure> onPeriodic
    private timer periodicTimer = null
    protected DispelLevel dispelLevel
    protected boolean destroyed = false

    private int customData = 0

    private construct(unit target, unit caster, real duration, BuffType buffType, int level)
        buffCount++
       
        this.expireTimer = getTimer()
            ..setData(this castTo int)
        if duration > -0.5
            this.expireTimer.start(duration, function expireStatic)

        if getBuffListFunction.getBuffList(target) == null //allocate new buffList
            createBuffListFunction.createBuffList(target)

        this.caster = caster
        this.target = target
        this.level = level
        this.buffType = buffType
        this.onFirst = buffType.onFirst
        this.onStack = buffType.onStack
        this.onApply = buffType.onApply
        this.onExpire = buffType.onExpire
        this.onDispel = buffType.onDispel
        this.onEnd = buffType.onEnd
        this.onPeriodic = buffType.onPeriodic

        this.dispelLevel = buffType.getDispelLevel()

        if(this.onPeriodic!=null)
            this.periodicTimer = getTimer()
                ..setData(this castTo int)
                ..startPeriodic(buffType.getPeriodicTime(), function onPeriodicStatic)
        else
            this.periodicTimer = null

        getBuffListFunction.getBuffList(target).add(this)
        if this.onFirst!=null
            for BuffEventClosure cb in this.onFirst
                cb.run(this)
        if this.onApply!=null
            for BuffEventClosure cb in this.onApply
                cb.run(this)

        
        


    static function applyBuff(unit target, unit caster, real duration, BuffType buffType, int level)
        let oldBuff = BuffList.getBuffOfType(target, buffType)
        if oldBuff != null
            oldBuff.update(caster, duration, level)
        else
            new Buff(target, caster, duration, buffType, level)
        

    private function onPeriodic()
        if not destroyed
            if(this.onPeriodic!=null)
                for BuffEventClosure cb in this.onPeriodic
                    cb.run(this)

    private static function onPeriodicStatic()
        let t = GetExpiredTimer()
        let thisBuff = t.getData() castTo Buff
        if thisBuff != null
            thisBuff.onPeriodic()
        
    
    private function expire()
        if(this.onExpire!=null)
            for BuffEventClosure cb in this.onExpire
                cb.run(this)
        if(this.onEnd!=null)
            for BuffEventClosure cb in this.onEnd
                cb.run(this)
        destroy this

    function dispel()
        execute() () ->
            if(this.onDispel!=null)
                for BuffEventClosure cb in this.onDispel
                    cb.run(this)
            if(this.onEnd!=null)
                for BuffEventClosure cb in this.onEnd
                    cb.run(this)
        destroy this


    private static function expireStatic()
        let t = GetExpiredTimer()
        let thisBuff = t.getData() castTo Buff
        if thisBuff != null
            thisBuff.expire()
        
    private function update(unit newCaster, real newDuration, int newLevel)
        this.caster = newCaster
        this.level = newLevel
        if this.onApply!=null
            for BuffEventClosure cb in this.onApply
                cb.run(this)
        if this.onStack!=null
            for BuffEventClosure cb in this.onStack
                cb.run(this)
        if newDuration < -0.5 or newDuration > this.expireTimer.getRemaining()
            this.expireTimer.release()
            this.expireTimer = getTimer()
                ..setData(this castTo int)
            if newDuration > -0.5
                this.expireTimer.start(newDuration, function expireStatic)

    function getDispelLevel() returns DispelLevel
        return this.dispelLevel

    function getCaster() returns unit
        return this.caster

    function getTarget() returns unit
        return this.target

    function getBuffType() returns BuffType
        return this.buffType

    function getRemaining() returns real
        return this.expireTimer.getRemaining()

    function getLevel() returns int
        return this.level

    function getData() returns int
        return this.customData

    function setData(int data)
        this.customData = data

    ondestroy
        buffCount--
        destroyed = true

        let buffList = getBuffListFunction.getBuffList(target)

        if buffList!=null
            buffList.remove(this)

        this.expireTimer.release()
        this.expireTimer.setData(0) //binds null to the timer
        if this.periodicTimer != null
            this.periodicTimer.release()
            this.periodicTimer.setData(0) //binds null to the timer

        this.customData = 0
        //do not modify triggers. They belong to the BuffType

public function debugBuff()
    print("BuffTypeCount = "+buffTypeCount.toString())
    print("BuffListCount = "+buffListCount.toString())
    print("BuffCount = "+buffCount.toString())